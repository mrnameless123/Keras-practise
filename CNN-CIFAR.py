from __future__ import print_function
import keras
from keras.datasets import cifar10
from keras.preprocessing.image import ImageDataGenerator
from keras.models import Sequential
from keras.layers import Dense, MaxPooling2D, Conv2D, Dropout, Flatten, Activation
import os

batch_size = 32
num_classes = 30
epochs = 200
data_augumentation = True
num_predictions = 20
save_dir = os.path.join(os.getcwd(), 'saved_models')
model_name = 'keras_cifar10_trained_model.h5'

#data,, shuffle and split between train and test sets
(x_train, y_train), (x_test, y_test) = cifar10.load_data()
print('x_train, shape: ', x_train.shape)
print(x_train.shape[0], 'train_samples')
print(x_test.shape[0], 'test samples')

y_train = keras.utils.to_categorical(y_train, num_classes) #transform label into one-hot coding form for softmax fuc
y_test = keras.utils.to_categorical(y_test, num_classes) #transform label into one-hot coding form for softmax fuc

x_train = x_train.astype('float32')
x_test = x_test.astype('float32')
x_train /= 255 #normalize the data
x_test  /= 255 #normalize the data

def CNN_model(train_set, label_set, test_set, test_label):
    model = Sequential()
    model.add(Conv2D(32, (3,3), padding='same', input_shape=x_train.shape[1:], activation='relu'))
    model.add(Conv2D(32, kernel_size = (3,3), padding='valid', activation='relu'))
    model.add(MaxPooling2D(pool_size=(2,2)))
    model.add(Dropout(0.25))

    model.add(Conv2D(64, (3,3), padding='same', activation='relu'))
    model.add(Conv2D(64, (3,3), padding='valid', activation='relu'))
    model.add(MaxPooling2D(pool_size=(2,2)))
    model.add(Dropout(0.25))

    model.add(Flatten())
    model.add(Dense(512))
    model.add(Activation('relu'))
    model.add(Dropout(0.5))
    model.add(Dense(num_classes, activation='softmax'))

    opt = keras.optimizers.rmsprop(lr = 0.0001, decay=1e-6)

    model.compile(loss='categorical_crossentropy', optimizer=opt, metrics=['accuracy'])

    if not data_augumentation:
        print('Not using data augmentation')
        model.fit(train_set, label_set,
                  batch_size= batch_size,
                  epochs = epochs,
                  validation_data=(test_set, y_test),
                  shuffle=True)
    else:
        print('Using real-time data augmentation')
        datagen = ImageDataGenerator(featurewise_center=False,
                                     samplewise_center=False,
                                     featurewise_std_normalization=False,
                                     samplewise_std_normalization=False,
                                     zca_whitening=False,
                                     rotation_range=0,
                                     width_shift_range=0.1, #randomly shift images horizontally (fractional of total width)
                                     height_shift_range=0.1,#randomly shift images vertically (fractional of total height)
                                     horizontal_flip=True, #flip the image horizontally
                                     vertical_flip=False ) #randomly flip the image

        #TODO: Compute the quantities required for feature-wise normalization
        #(std, mean, and principal components if ZCA whitening is applied)
        datagen.fit(train_set)

        #Fit the model on the batches generated by datagen.flow().
        model.fit_generator(datagen.flow(train_set, label_set,
                                         batch_size=batch_size),
                            steps_per_epoch= train_set.shape[0] // batch_size,
                            epochs = epochs,
                            validation_data=(test_set, test_label),
                            workers=4)

        #save model and weights
    if not os.path.isdir(save_dir):
        os.makedirs(save_dir)
    model_path = os.path.join(save_dir, model_name)
    model.save(model_path)
    print('Save Trained model at %s' %model_path)

    # Score trained model.
    scores = model.evaluate(x_test, y_test, verbose=1)
    print('Test loss:', scores[0])
    print('Test accuracy:', scores[1])

if __name__ == '__main__':
    CNN_model(x_train, y_train, x_test, y_test)

